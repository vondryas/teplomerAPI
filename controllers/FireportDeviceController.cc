/**
 *
 *  FireportDeviceController.cc
 *  This file is generated by drogon_ctl
 *
 */

#include "FireportDeviceController.h"
#include <string>
#include <controllers/ownershipUtils/Ownership.h>




Task<HttpResponsePtr> FireportDeviceController::getOne(const HttpRequestPtr req, const std::string& id)
{
	HttpResponsePtr resp = nullptr;
	std::string idclone = id;
	if (id.empty())
	{
		LOG_ERROR << "Id parameter is empty";
		co_return responses::wrongRequestResponse("Id parameter is required");
	}
	auto role = getRoleFromRequest(req);
	if (role == UserRoles::admin)
	{
		LOG_INFO << "Admin get by id fireport";
		auto data = co_await coroTryFacadeCall(facade_->getById(id), "getOne", idclone, resp);
		if (!data.has_value()) {
			co_return resp;
		}
		co_return responses::jsonOkResponse(data->toJson());
	}
	else
	{

		LOG_INFO << "User get by id fireport";
		std::string ownerId = getUserIdFromRequest(req);

		auto data = co_await coroTryFacadeCall(facade_->getByIdOwner(id, ownerId), "getOneOwner", idclone, resp);
		if (!data.has_value()) {
			if (resp && resp->getStatusCode() == k404NotFound) {
				co_return responses::forbiddenResponse("Fireport device not found or you don't have access to it");
			}
			co_return resp;
		}
		co_return responses::jsonOkResponse(data->toJson());
	}
}

Task<HttpResponsePtr> FireportDeviceController::getAllOwner(const HttpRequestPtr req)
{
	HttpResponsePtr resp = nullptr;
	std::string ownerId = getUserIdFromRequest(req);
	auto dataList = co_await coroTryFacadeCall(
		facade_->getAllByOwner(ownerId),
		"getAllOwner",
		fmt::format("ownerId: {}", ownerId),
		resp
	);
	if (!dataList.has_value()) {
		co_return resp;
	}
	co_return responses::jsonOkResponse(dataList->toJson());
}

Task<HttpResponsePtr> FireportDeviceController::getAll(const HttpRequestPtr req)
{
	HttpResponsePtr resp = nullptr;
	auto dataList = co_await coroTryFacadeCall(
		facade_->getAll(),
		"getAll",
		"admin getAll",
		resp
	);
	if (!dataList.has_value()) {
		co_return resp;
	}
	co_return responses::jsonOkResponse(dataList->toJson());
}

Task<HttpResponsePtr> FireportDeviceController::updateOne(const HttpRequestPtr req, const request_model::FireportDeviceDataRequest& model)
{
	HttpResponsePtr resp = nullptr;
	if (model.isEmpty())
	{
		LOG_ERROR << "Request data is empty";
		co_return responses::wrongRequestResponse("Request data is required");
	}
	auto [result, errorMessage] = model.validateForUpdate();
	if (!result)
	{
		LOG_ERROR << "Request data not valid: " << errorMessage;
		co_return responses::wrongRequestResponse(errorMessage);
	}
	auto updatedRows = co_await coroTryFacadeCall(
		facade_->update(model),
		"updateOne",
		fmt::format("id: {}", model.id.has_value() ? uuids::to_string(*model.id) : "null"),
		resp
	);
	if (!updatedRows.has_value()) {
		co_return resp;
	}
	co_return responses::sizeOkResponse(*updatedRows);
}

Task<HttpResponsePtr> FireportDeviceController::deleteOne(const HttpRequestPtr req, const std::string& id)
{
	HttpResponsePtr resp = nullptr;
	if (id.empty())
	{
		LOG_ERROR << "Id parameter is empty";
		co_return responses::wrongRequestResponse("Id parameter is required");
	}
	auto deletedRows = co_await coroTryFacadeCall(
		facade_->deleteById(id),
		"deleteOne",
		id,
		resp
	);
	if (!deletedRows.has_value()) {
		co_return resp;
	}
	co_return responses::sizeOkResponse(*deletedRows);
}

Task<HttpResponsePtr> FireportDeviceController::create(const HttpRequestPtr req, const request_model::FireportDeviceDataRequest& model)
{
	HttpResponsePtr resp = nullptr;
	if (model.isEmpty())
	{
		LOG_ERROR << "Request data is empty";
		co_return responses::wrongRequestResponse("Request data is required");
	}
	auto [result, errorMessage] = model.validateForCreate();
	if (!result)
	{
		LOG_ERROR << "Request data not valid: " << errorMessage;
		co_return responses::wrongRequestResponse(errorMessage);
	}
	auto createdId = co_await coroTryFacadeCall(
		facade_->create(model),
		"create",
		fmt::format("deviceId: {}", model.deviceId.empty() ? "null" : model.deviceId),
		resp
	);
	if (!createdId.has_value()) {
		co_return resp;
	}
	co_return responses::jsonOkResponse(createdId->toJson());
}

Task<HttpResponsePtr> FireportDeviceController::notifyDeviceByIdOwner(const HttpRequestPtr req, const std::string& id)
{
	HttpResponsePtr resp = nullptr;
	if (id.empty())
	{
		LOG_ERROR << "Id parameter is empty";
		co_return responses::wrongRequestResponse("Id parameter is required");
	}
	std::string ownerId = getUserIdFromRequest(req);
	auto notifyResult = co_await coroTryFacadeCall(
		facade_->NotifyDeviceByIdOwner(id),
		"notifyDeviceByIdOwner",
		fmt::format("id: {}, ownerId: {}", id, ownerId),
		resp
	);
	if (!notifyResult.has_value()) {
		co_return resp;
	}
	if (*notifyResult)
	{
		co_return responses::okResponse("Notification sent successfully");
	}
	else
	{
		co_return responses::internalServerErrorResponse("Failed to send notification");
	}


}

Task<HttpResponsePtr> FireportDeviceController::notifyDeviceById(const HttpRequestPtr req, const std::string& id)
{
	HttpResponsePtr resp = nullptr;
	if (id.empty())
	{
		LOG_ERROR << "Id parameter is empty";
		co_return responses::wrongRequestResponse("Id parameter is required");
	}
	auto notifyResult = co_await coroTryFacadeCall(
		facade_->NotifyDeviceById(id),
		"notifyDeviceById",
		fmt::format("id: {}", id),
		resp
	);
	if (!notifyResult.has_value()) {
		co_return resp;
	}
	if (*notifyResult)
	{
		co_return responses::okResponse("Notification sent successfully");
	}
	else
	{
		co_return responses::internalServerErrorResponse("Failed to send notification");
	}

}

Task<HttpResponsePtr> FireportDeviceController::notifyDeviceAllOwner(const HttpRequestPtr req)
{
	HttpResponsePtr resp = nullptr;
	std::string ownerId = getUserIdFromRequest(req);
	auto notifyResult = co_await coroTryFacadeCall(
		facade_->NotifyDeviceAllOwner(ownerId),
		"notifyDeviceAllOwner",
		fmt::format("ownerId: {}", ownerId),
		resp
	);
	if (!notifyResult.has_value()) {
		co_return resp;
	}
	if (*notifyResult)
	{
		co_return responses::okResponse("Notification sent successfully");
	}
	else
	{
		co_return responses::internalServerErrorResponse("Failed to send notification");
	}

}

Task<HttpResponsePtr> FireportDeviceController::notifyDeviceAll(const HttpRequestPtr req)
{
	HttpResponsePtr resp = nullptr;
	auto notifyResult = co_await coroTryFacadeCall(
		facade_->NotifyAllDevices(),
		"notifyDeviceAll",
		"admin notify all",
		resp
	);
	if (!notifyResult.has_value()) {
		co_return resp;
	}
	if (*notifyResult)
	{
		co_return responses::okResponse("Notification sent successfully");
	}
	else
	{
		co_return responses::internalServerErrorResponse("Failed to send notification");
	}
}
