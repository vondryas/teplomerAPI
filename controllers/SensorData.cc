/**
 *
 *  SensorData.cc
 *  This file is generated by drogon_ctl
 *
 */

#include "SensorData.h"
#include <string>
#include <fmt/core.h>
#include <cstdlib> 


Task<HttpResponsePtr> SensorData::getById(const HttpRequestPtr req, const std::string& idStr)
{
	HttpResponsePtr resp = nullptr;
	if (idStr.empty())
	{
		LOG_ERROR << "Id parameter is empty";
		co_return responses::wrongRequestResponse("Id parameter is required");
	}
	auto id = tryParse<int32_t>(idStr, "Id", resp);
	if (!id.has_value())
		co_return resp;

	LOG_DEBUG << "Fetching SensorData with id: " << idStr;

	auto data = co_await coroTryFacadeCall(facade_->getById(id.value()), "getById", idStr, resp);
	if (!data.has_value()) {
		co_return resp;
	}

	co_return responses::JsonOkResponse(data->toJson());
}



Task<HttpResponsePtr> SensorData::get(const HttpRequestPtr req)
{
	HttpResponsePtr resp = nullptr;
	std::optional<size_t> page = 1;
	std::optional<size_t> limit = 20;
	std::string pageStr = req->getParameter("page");
	LOG_DEBUG << "page" << pageStr;
	std::string limitStr = req->getParameter("limit");
	LOG_DEBUG << "limit" << limitStr;
	std::optional<mvector<drogon_model::teplomer_db::SensorData>> dataList;
	if (!pageStr.empty() || !limitStr.empty())
	{
		if (!pageStr.empty())
		{
			page = tryParse<size_t>(pageStr, "Page", resp);
			if (!page.has_value())
				co_return resp;
		}

		if (!limitStr.empty())
		{
			limit = tryParse<size_t>(limitStr, "Limit", resp);
			if (!page.has_value())
				co_return resp;
		}
		UUID

		dataList = co_await coroTryFacadeCall(
			facade_->getPaginated(page.value(), limit.value()),
			"getAll",
			fmt::format("page: {}, limit: {}", page.value(), limit.value()),
			resp
		);
	}
	else
	{
		dataList = co_await coroTryFacadeCall(facade_->getAll(), "getAll", "none", resp);
		if (!dataList.has_value()) {
			co_return resp;
		}
	}

	co_return responses::JsonOkResponse(dataList->toJson());
}




Task<HttpResponsePtr> SensorData::updateOne(const HttpRequestPtr req, const request_model::SensorData& data)
{
	co_return drogon::HttpResponse::newHttpResponse();
}

Task<HttpResponsePtr> SensorData::deleteOne(const HttpRequestPtr req, const std::string& id)
{
	co_return drogon::HttpResponse::newHttpResponse();
}

Task<HttpResponsePtr> SensorData::create(const HttpRequestPtr req, const request_model::SensorData& data)
{
	co_return drogon::HttpResponse::newHttpResponse();;
}
