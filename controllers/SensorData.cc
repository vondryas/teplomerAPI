/**
 *
 *  SensorData.cc
 *  This file is generated by drogon_ctl
 *
 */

#include "SensorData.h"
#include <string>



void SensorData::getOne(const HttpRequestPtr& req,
	std::function<void(const HttpResponsePtr&)>&& callback,
	std::string&& id)
{

	LOG_DEBUG << "SensorData::getOne called with id: " << id;
	auto resp = HttpResponse::newHttpResponse();
	resp->setStatusCode(drogon::k200OK);
	resp->setContentTypeCode(drogon::CT_TEXT_PLAIN);
	resp->setBody("ok");
	callback(resp);
}

void SensorData::get(const HttpRequestPtr& req,
	std::function<void(const HttpResponsePtr&)>&& callback)
{
}
void SensorData::create(const HttpRequestPtr& req,
	std::function<void(const HttpResponsePtr&)>&& callback,
	request_model::SensorData&& data)
{
	orm::DbClientPtr dbClient = drogon::app().getDbClient();
	if (!dbClient)
	{
		LOG_ERROR << "No database client available";
		auto resp = drogon::HttpResponse::newHttpResponse();
		resp->setStatusCode(drogon::k500InternalServerError);
		resp->setContentTypeCode(drogon::CT_TEXT_PLAIN);
		resp->setBody("Database client not available");
		callback(resp);
		return;
	}
	orm::Mapper<drogon_model::teplomer_db::SensorData> mapper(dbClient);
	mapper.findAll(
		[callback](const std::vector<drogon_model::teplomer_db::SensorData>& rcb) {
			for (const auto& data : rcb)
			{
				LOG_DEBUG << "SensorData found: " << data.getPrimaryKey();
			}
			auto resp = drogon::HttpResponse::newHttpResponse();
			resp->setStatusCode(drogon::k200OK);
			resp->setContentTypeCode(drogon::CT_TEXT_PLAIN);
			resp->setBody("ok");
			callback(resp);
		},
		[callback](const drogon::orm::DrogonDbException& e) {
			LOG_ERROR << "Error creating SensorData: " << e.base().what();
			auto resp = drogon::HttpResponse::newHttpResponse();
			resp->setStatusCode(drogon::k500InternalServerError);
			resp->setContentTypeCode(drogon::CT_TEXT_PLAIN);
			resp->setBody("Error creating SensorData");
			callback(resp);
		}
	);

}

void SensorData::updateOne(const HttpRequestPtr& req,
	std::function<void(const HttpResponsePtr&)>&& callback,
	request_model::SensorData&& data)
{
	LOG_DEBUG << "SensorData::updateOne called with id: " << data.id;
	LOG_INFO << data.isEmpty();
	if (data.isEmpty())
	{
		auto resp = drogon::HttpResponse::newHttpResponse();
		resp->setStatusCode(drogon::k400BadRequest);
		resp->setContentTypeCode(drogon::CT_TEXT_PLAIN);
		resp->setBody("Invalid request");
		callback(resp);
		return;
	}
	auto resp = drogon::HttpResponse::newHttpResponse();
	resp->setStatusCode(drogon::k200OK);
	resp->setContentTypeCode(drogon::CT_TEXT_PLAIN);
	resp->setBody("ok");
	callback(resp);
}

void SensorData::deleteOne(const HttpRequestPtr& req,
	std::function<void(const HttpResponsePtr&)>&& callback,
	std::string&& id)
{
}
