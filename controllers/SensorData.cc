/**
 *
 *  SensorData.cc
 *  This file is generated by drogon_ctl
 *
 */

#include "SensorData.h"
#include <string>



void SensorData::getOne(const HttpRequestPtr& req,
	std::function<void(const HttpResponsePtr&)>&& callback,
	const std::string& id)
{

	LOG_DEBUG << "SensorData::getOne called with id: " << id;
	auto resp = HttpResponse::newHttpResponse();
	resp->setStatusCode(drogon::k200OK);
	resp->setContentTypeCode(drogon::CT_TEXT_PLAIN);
	resp->setBody("ok");
	callback(resp);
}


void SensorData::get(const HttpRequestPtr& req,
	std::function<void(const HttpResponsePtr&)>&& callback)
{
	LOG_DEBUG << "SensorData::get called";
	facade_->hello();
	/*
	std::string pageStr = req->getParameter("page");
	std::string limitStr = req->getParameter("limit");
	*/

	orm::DbClientPtr dbClient = drogon::app().getDbClient();
	if (!dbClient)
	{
		LOG_ERROR << "No database client available";
		auto resp = drogon::HttpResponse::newHttpResponse();
		resp->setStatusCode(drogon::k500InternalServerError);
		resp->setContentTypeCode(drogon::CT_TEXT_PLAIN);
		resp->setBody("Database client not available");
		callback(resp);
		return;
	}
	orm::Mapper<drogon_model::teplomer_db::SensorData> mapper(dbClient);
	mapper.findAll(
		onMultipleRows(callback),
		onError(callback)
	);
}

void SensorData::create(const HttpRequestPtr& req,
	std::function<void(const HttpResponsePtr&)>&& callback,
	request_model::SensorData&& data)
{
	orm::DbClientPtr dbClient = drogon::app().getDbClient();
	if (!dbClient)
	{
		LOG_ERROR << "No database client available";
		auto resp = drogon::HttpResponse::newHttpResponse();
		resp->setStatusCode(drogon::k500InternalServerError);
		resp->setContentTypeCode(drogon::CT_TEXT_PLAIN);
		resp->setBody("Database client not available");
		callback(resp);
		return;
	}
	orm::Mapper<drogon_model::teplomer_db::SensorData> mapper(dbClient);
	mapper.findAll(
		[callback](const std::vector<drogon_model::teplomer_db::SensorData>& rcb) {

			LOG_DEBUG << "SensorData found: ";

			auto resp = drogon::HttpResponse::newHttpResponse();
			resp->setStatusCode(drogon::k200OK);
			resp->setContentTypeCode(drogon::CT_TEXT_PLAIN);
			resp->setBody("ok");
			callback(resp);
		},
		onError(callback)
	);

}

void SensorData::updateOne(const HttpRequestPtr& req,
	std::function<void(const HttpResponsePtr&)>&& callback,
	request_model::SensorData&& data)
{
	LOG_DEBUG << "SensorData::updateOne called with id: " << data.id;
	LOG_INFO << data.isEmpty();
	if (data.isEmpty())
	{
		auto resp = drogon::HttpResponse::newHttpResponse();
		resp->setStatusCode(drogon::k400BadRequest);
		resp->setContentTypeCode(drogon::CT_TEXT_PLAIN);
		resp->setBody("Invalid request");
		callback(resp);
		return;
	}
	auto resp = drogon::HttpResponse::newHttpResponse();
	resp->setStatusCode(drogon::k200OK);
	resp->setContentTypeCode(drogon::CT_TEXT_PLAIN);
	resp->setBody("ok");
	callback(resp);
}

void SensorData::deleteOne(const HttpRequestPtr& req,
	std::function<void(const HttpResponsePtr&)>&& callback,
	std::string&& id)
{
}
