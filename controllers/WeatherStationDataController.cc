/**
 *
 *  WeatherStationDataController.cc
 *  This file is generated by drogon_ctl
 *
 */

#include "WeatherStationDataController.h"
#include <string>
#include <fmt/core.h>
#include <cstdlib> 


using WeatherStationDataList = list_model::WeatherStationDataList;

Task<HttpResponsePtr> WeatherStationDataController::getById(const HttpRequestPtr req, const std::string& idStr)
{
	HttpResponsePtr resp = nullptr;
	if (idStr.empty())
	{
		LOG_ERROR << "Id parameter is empty";
		co_return responses::wrongRequestResponse("Id parameter is required");
	}
	if (!uuids::uuid::is_valid_uuid(idStr))
	{
		LOG_DEBUG << "Invalid UUID format for id: " << idStr;
		co_return responses::wrongRequestResponse(fmt::format("Invalid UUID format for id: {}", idStr));
	}

	auto data = co_await coroTryFacadeCall(facade_->getById(idStr), "getById", idStr, resp);
	if (!data.has_value()) {
		co_return resp;
	}

	co_return responses::jsonOkResponse(data->toJson());
}



Task<HttpResponsePtr> WeatherStationDataController::get(const HttpRequestPtr req)
{
	HttpResponsePtr resp = nullptr;
	std::optional<size_t> page = 1;
	std::optional<size_t> limit = 20;
	std::string pageStr = req->getParameter("page");
	LOG_DEBUG << "page" << pageStr;
	std::string limitStr = req->getParameter("limit");
	LOG_DEBUG << "limit" << limitStr;
	std::optional<WeatherStationDataList> dataList;
	if (!pageStr.empty() || !limitStr.empty())
	{
		if (!pageStr.empty())
		{
			page = tryParse<size_t>(pageStr, "Page", resp);
			if (!page.has_value())
				co_return resp;
		}

		if (!limitStr.empty())
		{
			limit = tryParse<size_t>(limitStr, "Limit", resp);
			if (!page.has_value())
				co_return resp;
		}

		if (limit < 1 || page < 1)
		{
			LOG_ERROR << "Invalid page or limit value";
			co_return responses::wrongRequestResponse("Page and limit must be greater than 0");
		}

		dataList = co_await coroTryFacadeCall(
			facade_->getPaginated(page.value(), limit.value()),
			"getAll",
			fmt::format("page: {}, limit: {}", page.value(), limit.value()),
			resp
		);

	}
	else
	{
		dataList = co_await coroTryFacadeCall(facade_->getAll(), "getAll", "none", resp);

	}

	if (!dataList.has_value()) {
		co_return resp;
	}
	co_return responses::jsonOkResponse(dataList->toJson());
}




Task<HttpResponsePtr> WeatherStationDataController::updateOne(const HttpRequestPtr req, const request_model::WeatherStationDataRequest& data)
{
	HttpResponsePtr resp = nullptr;
	if (data.isEmpty())
	{
		LOG_ERROR << "Request data is empty";
		co_return responses::wrongRequestResponse("Request data is required");
	}
	auto [result, errorMessage] = data.validateForUpdate();
	if (!result)
	{
		LOG_ERROR << "Request data not valid: " << errorMessage;
		co_return responses::wrongRequestResponse(errorMessage);
	}


	auto updatedDataRows = co_await coroTryFacadeCall(
		facade_->update(data),
		"update",
		fmt::format("id: {}", data.id.has_value() ? uuids::to_string(*data.id) : "null"),
		resp
	);
	if (!updatedDataRows.has_value()) {
		co_return resp;
	}
	co_return responses::sizeOkResponse(*updatedDataRows);
}

Task<HttpResponsePtr> WeatherStationDataController::deleteOne(const HttpRequestPtr req, const std::string& id)
{
	HttpResponsePtr resp = nullptr;
	LOG_DEBUG << "delete";
	if (id.empty())
	{
		LOG_ERROR << "Id parameter is empty";
		co_return responses::wrongRequestResponse("Id parameter is required");
	}
	if (!uuids::uuid::is_valid_uuid(id))
	{
		LOG_DEBUG << "Invalid UUID format for id: " << id;
		co_return responses::wrongRequestResponse(fmt::format("Invalid UUID format for id: {}", id));
	}
	auto deletedRows = co_await coroTryFacadeCall(
		facade_->deleteById(id),
		"deleteById",
		id,
		resp
	);
	if (!deletedRows.has_value()) {
		co_return resp;
	}
	co_return responses::sizeOkResponse(*deletedRows);
}

Task<HttpResponsePtr> WeatherStationDataController::create(const HttpRequestPtr req, const request_model::WeatherStationDataRequest& data)
{
	HttpResponsePtr resp = nullptr;
	if (data.isEmpty())
	{
		LOG_ERROR << "Request data is empty";
		co_return responses::wrongRequestResponse("Request data is required");
	}
	auto [result, errorMessage] = data.validateForCreate();
	if (!result)
	{
		LOG_ERROR << "Request data not valid";
		co_return responses::wrongRequestResponse(errorMessage);
	}

	auto newData = co_await coroTryFacadeCall(
		facade_->create(data),
		"create",
		fmt::format("id: {}", data.id.has_value() ? uuids::to_string(*data.id) : "null"),
		resp
	);
	if (!newData.has_value()) {
		co_return resp;
	}
	co_return responses::jsonOkResponse(newData->toJson());
}
